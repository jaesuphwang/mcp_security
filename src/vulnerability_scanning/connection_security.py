# Copyright 2025 Jae Sup Hwang
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Connection Security Analyzer for MCP server connections.

This module checks the security of MCP connections, including transport security,
authentication mechanisms, authorization controls, and token security.
"""
import asyncio
import ssl
import socket
import json
from typing import Dict, List, Any, Optional, Tuple
from enum import Enum, auto
import uuid
import httpx

from core.utils.logging import get_logger
from core.config.settings import get_settings

settings = get_settings()

logger = get_logger(__name__)


class SecurityLevel(Enum):
    """Security level classifications for connection security components."""
    CRITICAL = auto()
    HIGH = auto()
    MEDIUM = auto()
    LOW = auto()
    INFO = auto()


class VulnerabilityType(Enum):
    """Types of vulnerabilities that can be detected."""
    TRANSPORT_SECURITY = "transport_security"
    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    TOKEN_SECURITY = "token_security"
    PROTOCOL_SECURITY = "protocol_security"


class ConnectionVulnerability:
    """Represents a detected vulnerability in an MCP connection."""
    
    def __init__(
        self,
        vulnerability_id: str,
        vulnerability_type: VulnerabilityType,
        security_level: SecurityLevel,
        title: str,
        description: str,
        remediation: str,
        details: Optional[Dict[str, Any]] = None
    ):
        """
        Initialize a new connection vulnerability.
        
        Args:
            vulnerability_id: Unique identifier for this vulnerability
            vulnerability_type: Type of vulnerability
            security_level: Severity level
            title: Short title describing the vulnerability
            description: Detailed description of the vulnerability
            remediation: Guidance for fixing the vulnerability
            details: Additional details specific to this vulnerability
        """
        self.vulnerability_id = vulnerability_id
        self.vulnerability_type = vulnerability_type
        self.security_level = security_level
        self.title = title
        self.description = description
        self.remediation = remediation
        self.details = details or {}
        self.created_at = datetime.now()
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert the vulnerability to a dictionary."""
        return {
            "vulnerability_id": self.vulnerability_id,
            "vulnerability_type": self.vulnerability_type.value,
            "security_level": self.security_level.name,
            "title": self.title,
            "description": self.description,
            "remediation": self.remediation,
            "details": self.details,
            "created_at": self.created_at.isoformat()
        }


class ConnectionSecurityAnalyzer:
    """
    Analyzes the security of MCP server connections.
    """
    
    def __init__(self):
        """Initialize the connection security analyzer."""
        self.vulnerabilities = []
    
    async def analyze_connection(
        self,
        hostname: str,
        port: int,
        use_ssl: bool = True,
        auth_token: Optional[str] = None,
        headers: Optional[Dict[str, str]] = None
    ) -> List[ConnectionVulnerability]:
        """
        Analyze the security of an MCP connection.
        
        Args:
            hostname: The hostname or IP address of the MCP server
            port: The port number for the connection
            use_ssl: Whether to use SSL/TLS for the connection
            auth_token: Optional authentication token for the connection
            headers: Optional additional headers for the connection
            
        Returns:
            A list of detected vulnerabilities
        """
        self.vulnerabilities = []
        
        # Check transport security
        await self.check_transport_security(hostname, port, use_ssl)
        
        # Check authentication
        if auth_token:
            await self.check_authentication(hostname, port, use_ssl, auth_token)
        
        # Check authorization and token security
        if auth_token:
            await self.check_authorization(hostname, port, use_ssl, auth_token, headers)
            await self.check_token_security(auth_token)
        
        return self.vulnerabilities
    
    async def check_transport_security(self, hostname: str, port: int, use_ssl: bool) -> None:
        """
        Check the transport security of an MCP connection.
        
        Args:
            hostname: The hostname or IP address
            port: The port number
            use_ssl: Whether SSL/TLS is used
        """
        # Check if SSL/TLS is being used
        if not use_ssl:
            self.vulnerabilities.append(ConnectionVulnerability(
                vulnerability_id=str(uuid.uuid4()),
                vulnerability_type=VulnerabilityType.TRANSPORT_SECURITY,
                security_level=SecurityLevel.CRITICAL,
                title="Unencrypted Connection",
                description="The MCP connection is not using SSL/TLS encryption, making it vulnerable to eavesdropping and man-in-the-middle attacks.",
                remediation="Enable SSL/TLS for all MCP connections. Use TLS 1.3 if possible, with a minimum of TLS 1.2."
            ))
            return
        
        # For SSL/TLS connections, check the certificate and cipher suites
        try:
            context = ssl.create_default_context()
            with socket.create_connection((hostname, port)) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    
                    # Check certificate validity
                    if not cert:
                        self.vulnerabilities.append(ConnectionVulnerability(
                            vulnerability_id=str(uuid.uuid4()),
                            vulnerability_type=VulnerabilityType.TRANSPORT_SECURITY,
                            security_level=SecurityLevel.CRITICAL,
                            title="Invalid SSL Certificate",
                            description="The server's SSL certificate is invalid or could not be verified.",
                            remediation="Install a valid SSL certificate from a trusted certificate authority."
                        ))
                    
                    # Check TLS version
                    if cipher and cipher[1] in ('TLSv1', 'TLSv1.1'):
                        self.vulnerabilities.append(ConnectionVulnerability(
                            vulnerability_id=str(uuid.uuid4()),
                            vulnerability_type=VulnerabilityType.TRANSPORT_SECURITY,
                            security_level=SecurityLevel.HIGH,
                            title="Outdated TLS Version",
                            description=f"The server is using an outdated TLS version: {cipher[1]}",
                            remediation="Upgrade to TLS 1.2 or preferably TLS 1.3. Disable older TLS versions.",
                            details={"current_version": cipher[1]}
                        ))
                    
                    # Check for weak cipher suites
                    if cipher and "NULL" in cipher[0] or "RC4" in cipher[0] or "DES" in cipher[0]:
                        self.vulnerabilities.append(ConnectionVulnerability(
                            vulnerability_id=str(uuid.uuid4()),
                            vulnerability_type=VulnerabilityType.TRANSPORT_SECURITY,
                            security_level=SecurityLevel.HIGH,
                            title="Weak Cipher Suite",
                            description=f"The server is using a weak cipher suite: {cipher[0]}",
                            remediation="Configure the server to use strong cipher suites and disable weak ones.",
                            details={"current_cipher": cipher[0]}
                        ))
        except Exception as e:
            logger.error(f"Error checking transport security: {e}")
            self.vulnerabilities.append(ConnectionVulnerability(
                vulnerability_id=str(uuid.uuid4()),
                vulnerability_type=VulnerabilityType.TRANSPORT_SECURITY,
                security_level=SecurityLevel.MEDIUM,
                title="Transport Security Check Failed",
                description="Could not complete transport security checks. This may indicate security issues.",
                remediation="Ensure the server is properly configured for SSL/TLS and is accessible.",
                details={"error": str(e)}
            ))
    
    async def check_authentication(self, hostname: str, port: int, use_ssl: bool, auth_token: str) -> None:
        """
        Check the authentication mechanisms of an MCP connection.
        
        Args:
            hostname: The hostname or IP address
            port: The port number
            use_ssl: Whether SSL/TLS is used
            auth_token: The authentication token
        """
        # Check token format and content
        if not auth_token:
            self.vulnerabilities.append(ConnectionVulnerability(
                vulnerability_id=str(uuid.uuid4()),
                vulnerability_type=VulnerabilityType.AUTHENTICATION,
                security_level=SecurityLevel.CRITICAL,
                title="Missing Authentication",
                description="No authentication token was provided for the connection.",
                remediation="Implement proper authentication using secure tokens (JWT or similar)."
            ))
            return
        
        # Check for basic JWT structure
        if auth_token.count('.') == 2:
            # Looks like a JWT, validate its structure
            try:
                import jwt
                
                # Just decode headers to check structure without verification
                header = jwt.get_unverified_header(auth_token)
                
                # Check algorithm
                if header and header.get('alg') == 'none':
                    self.vulnerabilities.append(ConnectionVulnerability(
                        vulnerability_id=str(uuid.uuid4()),
                        vulnerability_type=VulnerabilityType.AUTHENTICATION,
                        security_level=SecurityLevel.CRITICAL,
                        title="JWT Using 'none' Algorithm",
                        description="The JWT token uses the 'none' algorithm, which provides no security.",
                        remediation="Use a secure algorithm like RS256 or ES256 for JWT tokens."
                    ))
                elif header and header.get('alg') in ('HS256', 'HS384', 'HS512'):
                    # HMAC algorithms are acceptable but note potential for weak keys
                    pass
                
                # Try to check for token expiration
                try:
                    payload = jwt.decode(auth_token, options={"verify_signature": False})
                    if 'exp' not in payload:
                        self.vulnerabilities.append(ConnectionVulnerability(
                            vulnerability_id=str(uuid.uuid4()),
                            vulnerability_type=VulnerabilityType.AUTHENTICATION,
                            security_level=SecurityLevel.MEDIUM,
                            title="JWT Without Expiration",
                            description="The JWT token does not have an expiration claim, making it valid indefinitely.",
                            remediation="Add an expiration claim (exp) to all JWT tokens with a reasonable lifetime."
                        ))
                except:
                    # If we can't decode the payload, note it as a potential issue
                    self.vulnerabilities.append(ConnectionVulnerability(
                        vulnerability_id=str(uuid.uuid4()),
                        vulnerability_type=VulnerabilityType.AUTHENTICATION,
                        security_level=SecurityLevel.LOW,
                        title="JWT Format Issue",
                        description="The JWT token payload could not be decoded for analysis.",
                        remediation="Ensure JWT tokens follow the standard format with a valid payload."
                    ))
            except Exception as e:
                logger.error(f"Error analyzing JWT token: {e}")
    
    async def check_authorization(self, hostname: str, port: int, use_ssl: bool, auth_token: str, headers: Optional[Dict[str, str]] = None) -> None:
        """
        Check the authorization controls of an MCP connection.
        
        Args:
            hostname: The hostname or IP address
            port: The port number
            use_ssl: Whether SSL/TLS is used
            auth_token: The authentication token
            headers: Additional headers for the connection
        """
        # This would involve testing for permission boundaries, but we'll simplify for this example
        # In a real implementation, you would make API calls to check different permission levels
        
        # For now, we'll just note some common issues
        self.vulnerabilities.append(ConnectionVulnerability(
            vulnerability_id=str(uuid.uuid4()),
            vulnerability_type=VulnerabilityType.AUTHORIZATION,
            security_level=SecurityLevel.INFO,
            title="Authorization Check Required",
            description="A manual review of authorization controls is recommended.",
            remediation="Implement proper role-based access control and verify permission boundaries.",
            details={"note": "This is a placeholder for a real authorization check."}
        ))
    
    async def check_token_security(self, auth_token: str) -> None:
        """
        Check the security of the authentication token.
        
        Args:
            auth_token: The authentication token to check
        """
        # Check token length as a basic entropy check
        if len(auth_token) < 32:
            self.vulnerabilities.append(ConnectionVulnerability(
                vulnerability_id=str(uuid.uuid4()),
                vulnerability_type=VulnerabilityType.TOKEN_SECURITY,
                security_level=SecurityLevel.MEDIUM,
                title="Short Authentication Token",
                description="The authentication token is unusually short, which may indicate low entropy.",
                remediation="Use tokens with sufficient entropy (at least 256 bits of randomness)."
            ))
        
        # For JWT tokens, additional checks are done in the authentication check
        
        # Check for tokens in standard formats that might be using defaults
        if auth_token.startswith("sk-") and len(auth_token) < 60:
            self.vulnerabilities.append(ConnectionVulnerability(
                vulnerability_id=str(uuid.uuid4()),
                vulnerability_type=VulnerabilityType.TOKEN_SECURITY,
                security_level=SecurityLevel.LOW,
                title="Potentially Predictable Token Format",
                description="The token follows a predictable format which may be easier to guess or brute force.",
                remediation="Use random, high-entropy tokens that don't follow easily recognizable patterns."
            ))


# Create a singleton instance
connection_security_analyzer = ConnectionSecurityAnalyzer() 