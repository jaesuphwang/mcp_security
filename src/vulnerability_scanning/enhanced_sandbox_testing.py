"""
Enhanced Sandbox Testing System that uses real Docker sandbox when available.
"""
from typing import Dict, Any, Optional, List
import asyncio
from datetime import datetime
import uuid

from core.utils.logging import get_logger
from core.models.vulnerability import SandboxTestResult

# Import the original sandbox testing components
from .sandbox_testing import (
    SandboxTestingSystem as SimulatedSandbox,
    TestCategory,
    USE_REAL_SANDBOX,
    real_sandbox_instance
)

logger = get_logger(__name__)


class EnhancedSandboxTestingSystem:
    """
    Enhanced sandbox testing system that uses real Docker isolation when available,
    falling back to simulated testing when Docker is not available.
    """
    
    def __init__(self):
        self.use_real_sandbox = USE_REAL_SANDBOX
        self.simulated_sandbox = SimulatedSandbox()
        self.real_sandbox = real_sandbox_instance
        
        logger.info(f"Enhanced sandbox initialized. Using real sandbox: {self.use_real_sandbox}")
    
    async def test_server(self, server_id: str, server_url: str) -> SandboxTestResult:
        """
        Test an MCP server using the best available sandbox method.
        
        Args:
            server_id: ID of the server to test
            server_url: URL of the server to test
            
        Returns:
            SandboxTestResult with comprehensive test results
        """
        if self.use_real_sandbox and self.real_sandbox:
            logger.info(f"Testing server {server_id} using real Docker sandbox")
            try:
                # Use the real sandbox with Docker isolation
                result = await self.real_sandbox.test_server(server_id, server_url)
                logger.info(f"Real sandbox test completed. Risk score: {result.risk_score}")
                return result
            except Exception as e:
                logger.error(f"Real sandbox test failed: {str(e)}. Falling back to simulated sandbox.")
                # Fall back to simulated if real sandbox fails
                return await self._run_simulated_test(server_id, server_url)
        else:
            logger.info(f"Testing server {server_id} using simulated sandbox")
            return await self._run_simulated_test(server_id, server_url)
    
    async def _run_simulated_test(self, server_id: str, server_url: str) -> SandboxTestResult:
        """Run simulated sandbox test."""
        # Run the simulated test suite
        test_summary = await self.simulated_sandbox.run_test_suite(server_url)
        
        # Convert simulated results to SandboxTestResult format
        vulnerabilities = []
        for vuln_data in test_summary.get("vulnerabilities", []):
            from core.models.vulnerability import SandboxVulnerability
            vulnerabilities.append(SandboxVulnerability(
                test_name=vuln_data.get("test_id", "unknown"),
                vulnerability_type=vuln_data.get("title", "Unknown Vulnerability"),
                severity=self._map_security_level(vuln_data.get("security_level")),
                description=vuln_data.get("description", ""),
                evidence=vuln_data.get("details", {}),
                remediation=vuln_data.get("remediation", "")
            ))
        
        return SandboxTestResult(
            test_id=test_summary.get("test_suite_id", str(uuid.uuid4())),
            timestamp=datetime.utcnow(),
            server_id=server_id,
            total_tests=test_summary.get("total_tests", 0),
            tests_completed=test_summary.get("passed_tests", 0) + test_summary.get("failed_tests", 0),
            vulnerabilities=vulnerabilities,
            risk_score=test_summary.get("risk_score", 0.0) / 10.0,  # Normalize to 0-1
            test_duration=0.0,  # Simulated tests don't track duration
            detailed_report=test_summary
        )
    
    def _map_security_level(self, level) -> str:
        """Map security level enum to string."""
        if hasattr(level, 'value'):
            level = level.value
        
        level_map = {
            'CRITICAL': 'critical',
            'HIGH': 'high',
            'MEDIUM': 'medium',
            'LOW': 'low'
        }
        
        return level_map.get(str(level).upper(), 'medium')
    
    async def run_specific_tests(
        self,
        server_id: str,
        server_url: str,
        test_categories: Optional[List[TestCategory]] = None
    ) -> SandboxTestResult:
        """
        Run specific categories of tests against a server.
        
        Args:
            server_id: ID of the server to test
            server_url: URL of the server to test
            test_categories: Optional list of test categories to run
            
        Returns:
            SandboxTestResult with test results
        """
        if self.use_real_sandbox and self.real_sandbox:
            # Real sandbox runs all tests by default
            return await self.test_server(server_id, server_url)
        else:
            # Use simulated sandbox with category filtering
            test_summary = await self.simulated_sandbox.run_test_suite(
                server_url,
                categories=test_categories
            )
            return await self._run_simulated_test(server_id, server_url)
    
    def get_sandbox_status(self) -> Dict[str, Any]:
        """Get the current status of the sandbox system."""
        status = {
            "sandbox_type": "docker" if self.use_real_sandbox else "simulated",
            "docker_available": self.use_real_sandbox,
            "features": {
                "real_isolation": self.use_real_sandbox,
                "network_monitoring": self.use_real_sandbox,
                "file_system_monitoring": self.use_real_sandbox,
                "resource_limits": self.use_real_sandbox,
                "secure_runtime": self.use_real_sandbox and hasattr(self.real_sandbox, 'runtime') and self.real_sandbox.sandbox.runtime is not None
            }
        }
        
        if self.use_real_sandbox:
            try:
                import docker
                client = docker.from_env()
                info = client.info()
                status["docker_info"] = {
                    "version": info.get("ServerVersion"),
                    "runtime": info.get("DefaultRuntime"),
                    "security_options": info.get("SecurityOptions", [])
                }
            except Exception as e:
                status["docker_info"] = {"error": str(e)}
        
        return status


# Create a singleton instance
enhanced_sandbox_testing_system = EnhancedSandboxTestingSystem()