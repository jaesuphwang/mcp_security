# Copyright 2025 Jae Sup Hwang
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Server Capability Auditor for MCP servers.

This module analyzes MCP server capabilities, assesses the risk of capability combinations,
verifies permission boundaries, and provides recommendations for implementing least privilege.
"""
import asyncio
import json
from typing import Dict, List, Any, Optional, Set, Tuple
from enum import Enum, auto
import uuid
import httpx

from core.utils.logging import get_logger
from core.config.settings import get_settings

settings = get_settings()
from vulnerability_scanning.connection_security import SecurityLevel, ConnectionVulnerability

logger = get_logger(__name__)


class CapabilityRiskLevel(Enum):
    """Risk levels for MCP server capabilities."""
    CRITICAL = auto()
    HIGH = auto()
    MEDIUM = auto()
    LOW = auto()
    MINIMAL = auto()


class MCPCapability:
    """Represents a capability exposed by an MCP server."""
    
    def __init__(
        self,
        capability_id: str,
        name: str,
        description: str,
        risk_level: CapabilityRiskLevel,
        permissions: List[str],
        resources: List[str],
        metadata: Optional[Dict[str, Any]] = None
    ):
        """
        Initialize a new MCP capability.
        
        Args:
            capability_id: Unique identifier for this capability
            name: Name of the capability
            description: Description of what the capability does
            risk_level: Risk level associated with this capability
            permissions: List of permissions required for this capability
            resources: List of resources this capability can access
            metadata: Additional metadata about this capability
        """
        self.capability_id = capability_id
        self.name = name
        self.description = description
        self.risk_level = risk_level
        self.permissions = permissions
        self.resources = resources
        self.metadata = metadata or {}
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert the capability to a dictionary."""
        return {
            "capability_id": self.capability_id,
            "name": self.name,
            "description": self.description,
            "risk_level": self.risk_level.name,
            "permissions": self.permissions,
            "resources": self.resources,
            "metadata": self.metadata
        }


class CapabilityVulnerability(ConnectionVulnerability):
    """Represents a vulnerability related to MCP server capabilities."""
    
    def __init__(
        self,
        vulnerability_id: str,
        security_level: SecurityLevel,
        title: str,
        description: str,
        remediation: str,
        capabilities: List[str],
        details: Optional[Dict[str, Any]] = None
    ):
        """
        Initialize a new capability vulnerability.
        
        Args:
            vulnerability_id: Unique identifier for this vulnerability
            security_level: Severity level
            title: Short title describing the vulnerability
            description: Detailed description of the vulnerability
            remediation: Guidance for fixing the vulnerability
            capabilities: List of capability IDs involved in this vulnerability
            details: Additional details specific to this vulnerability
        """
        from vulnerability_scanning.connection_security import VulnerabilityType
        super().__init__(
            vulnerability_id=vulnerability_id,
            vulnerability_type=VulnerabilityType.AUTHORIZATION,
            security_level=security_level,
            title=title,
            description=description,
            remediation=remediation,
            details=details or {}
        )
        self.capabilities = capabilities
        self.details["capabilities"] = capabilities


class CapabilityRelationship:
    """Represents a relationship between two MCP server capabilities."""
    
    def __init__(
        self,
        relationship_id: str,
        source_capability: str,
        target_capability: str,
        relationship_type: str,
        risk_level: CapabilityRiskLevel,
        description: str,
        metadata: Optional[Dict[str, Any]] = None
    ):
        """
        Initialize a new capability relationship.
        
        Args:
            relationship_id: Unique identifier for this relationship
            source_capability: ID of the source capability
            target_capability: ID of the target capability
            relationship_type: Type of relationship between capabilities
            risk_level: Risk level of this relationship
            description: Description of the relationship and potential risks
            metadata: Additional metadata about this relationship
        """
        self.relationship_id = relationship_id
        self.source_capability = source_capability
        self.target_capability = target_capability
        self.relationship_type = relationship_type
        self.risk_level = risk_level
        self.description = description
        self.metadata = metadata or {}
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert the relationship to a dictionary."""
        return {
            "relationship_id": self.relationship_id,
            "source_capability": self.source_capability,
            "target_capability": self.target_capability,
            "relationship_type": self.relationship_type,
            "risk_level": self.risk_level.name,
            "description": self.description,
            "metadata": self.metadata
        }


# High-risk capability combinations that should be flagged
HIGH_RISK_COMBINATIONS = [
    {
        "capabilities": ["file_system_access", "process_execution"],
        "risk_level": CapabilityRiskLevel.CRITICAL,
        "title": "File Access and Process Execution",
        "description": "Combination allows reading files and executing code, enabling potential code execution attacks.",
        "remediation": "Separate these capabilities and implement strict controls on process execution."
    },
    {
        "capabilities": ["network_access", "file_system_access"],
        "risk_level": CapabilityRiskLevel.HIGH,
        "title": "Network and File System Access",
        "description": "Combination allows data exfiltration by reading files and sending them over the network.",
        "remediation": "Implement network controls to prevent outbound connections to unauthorized destinations."
    },
    {
        "capabilities": ["credential_access", "network_access"],
        "risk_level": CapabilityRiskLevel.CRITICAL,
        "title": "Credential Access and Network Access",
        "description": "Combination allows credential theft and exfiltration over the network.",
        "remediation": "Separate credential access from network access capabilities and implement strict access controls."
    },
    {
        "capabilities": ["database_access", "network_access"],
        "risk_level": CapabilityRiskLevel.HIGH,
        "title": "Database and Network Access",
        "description": "Combination allows database data exfiltration over the network.",
        "remediation": "Implement database access controls and network restrictions to prevent unauthorized data transfer."
    }
]


class ServerCapabilityAuditor:
    """
    Audits MCP server capabilities for security risks.
    """
    
    def __init__(self):
        """Initialize the server capability auditor."""
        self.capabilities = {}
        self.relationships = {}
        self.vulnerabilities = []
    
    async def discover_capabilities(self, server_url: str, auth_token: Optional[str] = None) -> List[MCPCapability]:
        """
        Discover capabilities exposed by an MCP server.
        
        Args:
            server_url: The URL of the MCP server
            auth_token: Optional authentication token
            
        Returns:
            A list of discovered capabilities
        """
        # In a real implementation, this would make API calls to the server
        # to discover available capabilities. For this example, we'll simulate
        # the discovery of common capabilities.
        
        # Reset capabilities
        self.capabilities = {}
        
        # Common MCP capabilities to check for
        common_capabilities = [
            {
                "id": "file_system_access",
                "name": "File System Access",
                "description": "Allows reading and writing files on the server",
                "risk_level": CapabilityRiskLevel.HIGH,
                "permissions": ["read", "write"],
                "resources": ["/files", "/uploads"]
            },
            {
                "id": "process_execution",
                "name": "Process Execution",
                "description": "Allows executing system commands or processes",
                "risk_level": CapabilityRiskLevel.CRITICAL,
                "permissions": ["execute"],
                "resources": ["/exec", "/run"]
            },
            {
                "id": "network_access",
                "name": "Network Access",
                "description": "Allows making network connections",
                "risk_level": CapabilityRiskLevel.HIGH,
                "permissions": ["connect"],
                "resources": ["/network", "/http"]
            },
            {
                "id": "database_access",
                "name": "Database Access",
                "description": "Allows querying and modifying databases",
                "risk_level": CapabilityRiskLevel.MEDIUM,
                "permissions": ["query", "update"],
                "resources": ["/db", "/data"]
            },
            {
                "id": "credential_access",
                "name": "Credential Access",
                "description": "Allows access to credentials or secrets",
                "risk_level": CapabilityRiskLevel.HIGH,
                "permissions": ["read"],
                "resources": ["/credentials", "/secrets"]
            },
            {
                "id": "log_access",
                "name": "Log Access",
                "description": "Allows reading system logs",
                "risk_level": CapabilityRiskLevel.LOW,
                "permissions": ["read"],
                "resources": ["/logs"]
            },
            {
                "id": "metadata_access",
                "name": "Metadata Access",
                "description": "Allows access to system metadata",
                "risk_level": CapabilityRiskLevel.LOW,
                "permissions": ["read"],
                "resources": ["/metadata", "/info"]
            }
        ]
        
        # Simulate capability discovery
        try:
            # In reality, you would make an API call to the server here
            # For now, let's assume some of these capabilities are available
            headers = {}
            if auth_token:
                headers["Authorization"] = f"Bearer {auth_token}"
            
            # Here we would make actual API calls to discover capabilities
            # For this example, we'll just use the common capabilities
            
            for cap in common_capabilities:
                # Simulate checking if capability is available
                # In reality, this would be determined by API responses
                # For this example, let's assume some capabilities are available
                if cap["id"] in ["file_system_access", "network_access", "log_access", "metadata_access"]:
                    capability = MCPCapability(
                        capability_id=cap["id"],
                        name=cap["name"],
                        description=cap["description"],
                        risk_level=cap["risk_level"],
                        permissions=cap["permissions"],
                        resources=cap["resources"]
                    )
                    self.capabilities[cap["id"]] = capability
        
        except Exception as e:
            logger.error(f"Error discovering capabilities: {e}")
        
        return list(self.capabilities.values())
    
    async def assess_capability_risks(self) -> List[CapabilityVulnerability]:
        """
        Assess the risks associated with discovered capabilities and their combinations.
        
        Returns:
            A list of identified vulnerabilities
        """
        # Reset vulnerabilities
        self.vulnerabilities = []
        
        # Check for high-risk individual capabilities
        for cap_id, capability in self.capabilities.items():
            if capability.risk_level in [CapabilityRiskLevel.CRITICAL, CapabilityRiskLevel.HIGH]:
                self.vulnerabilities.append(CapabilityVulnerability(
                    vulnerability_id=str(uuid.uuid4()),
                    security_level=SecurityLevel.HIGH if capability.risk_level == CapabilityRiskLevel.HIGH else SecurityLevel.CRITICAL,
                    title=f"High-Risk Capability: {capability.name}",
                    description=f"The server exposes a high-risk capability: {capability.description}",
                    remediation=f"Consider restricting or removing this capability if not absolutely necessary.",
                    capabilities=[capability.capability_id],
                    details={"capability": capability.to_dict()}
                ))
        
        # Check for high-risk capability combinations
        for combo in HIGH_RISK_COMBINATIONS:
            # Check if all capabilities in this combination are present
            if all(cap_id in self.capabilities for cap_id in combo["capabilities"]):
                self.vulnerabilities.append(CapabilityVulnerability(
                    vulnerability_id=str(uuid.uuid4()),
                    security_level=SecurityLevel.HIGH if combo["risk_level"] == CapabilityRiskLevel.HIGH else SecurityLevel.CRITICAL,
                    title=combo["title"],
                    description=combo["description"],
                    remediation=combo["remediation"],
                    capabilities=combo["capabilities"]
                ))
        
        return self.vulnerabilities
    
    async def map_capability_relationships(self) -> List[CapabilityRelationship]:
        """
        Map relationships between capabilities to identify potential attack paths.
        
        Returns:
            A list of capability relationships
        """
        # Reset relationships
        self.relationships = {}
        
        # Map relationships between capabilities
        capability_ids = list(self.capabilities.keys())
        for i, source_id in enumerate(capability_ids):
            for target_id in capability_ids[i+1:]:
                # Check if these capabilities have a known high-risk relationship
                for combo in HIGH_RISK_COMBINATIONS:
                    if source_id in combo["capabilities"] and target_id in combo["capabilities"]:
                        relationship = CapabilityRelationship(
                            relationship_id=str(uuid.uuid4()),
                            source_capability=source_id,
                            target_capability=target_id,
                            relationship_type="risk_combination",
                            risk_level=combo["risk_level"],
                            description=combo["description"],
                            metadata={"remediation": combo["remediation"]}
                        )
                        self.relationships[relationship.relationship_id] = relationship
        
        return list(self.relationships.values())
    
    async def verify_permission_boundaries(self) -> List[CapabilityVulnerability]:
        """
        Verify that capabilities have appropriate permission boundaries.
        
        Returns:
            A list of identified permission boundary vulnerabilities
        """
        # In a real implementation, this would check for proper isolation between
        # capabilities and verify that permissions are properly enforced.
        # For this example, we'll just check for some common permission issues.
        
        for cap_id, capability in self.capabilities.items():
            # Check for overly broad permissions
            if "write" in capability.permissions and cap_id in ["file_system_access"]:
                self.vulnerabilities.append(CapabilityVulnerability(
                    vulnerability_id=str(uuid.uuid4()),
                    security_level=SecurityLevel.HIGH,
                    title=f"Overly Broad Write Permissions: {capability.name}",
                    description=f"The capability has write permissions which may be unnecessarily broad.",
                    remediation=f"Restrict write permissions to specific directories or resources that are necessary.",
                    capabilities=[capability.capability_id],
                    details={"capability": capability.to_dict()}
                ))
        
        return [v for v in self.vulnerabilities if "Overly Broad" in v.title]
    
    async def generate_recommendations(self) -> Dict[str, Any]:
        """
        Generate recommendations for implementing least privilege.
        
        Returns:
            A dictionary of recommendations for each capability
        """
        recommendations = {}
        
        for cap_id, capability in self.capabilities.items():
            cap_recommendations = []
            
            # Generate recommendations based on capability type
            if cap_id == "file_system_access":
                cap_recommendations.extend([
                    "Limit file system access to specific directories",
                    "Use read-only access where possible",
                    "Implement file access auditing",
                    "Block access to sensitive system directories"
                ])
            elif cap_id == "process_execution":
                cap_recommendations.extend([
                    "Implement an allowlist of permitted commands",
                    "Run processes in a restricted environment",
                    "Limit process execution privileges",
                    "Log and monitor all process executions"
                ])
            elif cap_id == "network_access":
                cap_recommendations.extend([
                    "Restrict outbound connections to allowlisted destinations",
                    "Block access to sensitive internal networks",
                    "Implement network traffic monitoring",
                    "Use application-level firewalls"
                ])
            elif cap_id == "database_access":
                cap_recommendations.extend([
                    "Use parameterized queries to prevent injection",
                    "Implement row-level security where applicable",
                    "Limit database user privileges",
                    "Audit database access"
                ])
            elif cap_id == "credential_access":
                cap_recommendations.extend([
                    "Use a dedicated secret management service",
                    "Implement strict access controls for credentials",
                    "Rotate credentials regularly",
                    "Audit all credential access"
                ])
            else:
                cap_recommendations.append("Implement least privilege access controls")
            
            recommendations[cap_id] = {
                "capability": capability.to_dict(),
                "recommendations": cap_recommendations
            }
        
        return recommendations
    
    async def audit_server_capabilities(self, server_url: str, auth_token: Optional[str] = None) -> Dict[str, Any]:
        """
        Perform a complete audit of server capabilities.
        
        Args:
            server_url: The URL of the MCP server
            auth_token: Optional authentication token
            
        Returns:
            A comprehensive audit report
        """
        # Discover capabilities
        capabilities = await self.discover_capabilities(server_url, auth_token)
        
        # Assess risks
        vulnerabilities = await self.assess_capability_risks()
        
        # Map relationships
        relationships = await self.map_capability_relationships()
        
        # Verify permission boundaries
        boundary_vulnerabilities = await self.verify_permission_boundaries()
        
        # Generate recommendations
        recommendations = await self.generate_recommendations()
        
        # Compile the audit report
        audit_report = {
            "server_url": server_url,
            "audit_id": str(uuid.uuid4()),
            "capabilities": [cap.to_dict() for cap in capabilities],
            "vulnerabilities": [vuln.to_dict() for vuln in vulnerabilities],
            "relationships": [rel.to_dict() for rel in relationships],
            "recommendations": recommendations,
            "summary": {
                "capability_count": len(capabilities),
                "vulnerability_count": len(vulnerabilities),
                "high_risk_capabilities": sum(1 for cap in capabilities if cap.risk_level in [CapabilityRiskLevel.CRITICAL, CapabilityRiskLevel.HIGH]),
                "risk_score": self._calculate_risk_score()
            }
        }
        
        return audit_report
    
    def _calculate_risk_score(self) -> float:
        """
        Calculate an overall risk score based on capabilities and vulnerabilities.
        
        Returns:
            A risk score between 0.0 and 10.0
        """
        score = 0.0
        
        # Add points for high-risk capabilities
        for capability in self.capabilities.values():
            if capability.risk_level == CapabilityRiskLevel.CRITICAL:
                score += 2.5
            elif capability.risk_level == CapabilityRiskLevel.HIGH:
                score += 1.5
            elif capability.risk_level == CapabilityRiskLevel.MEDIUM:
                score += 0.75
            elif capability.risk_level == CapabilityRiskLevel.LOW:
                score += 0.25
        
        # Add points for vulnerabilities
        for vulnerability in self.vulnerabilities:
            if vulnerability.security_level == SecurityLevel.CRITICAL:
                score += 2.0
            elif vulnerability.security_level == SecurityLevel.HIGH:
                score += 1.0
            elif vulnerability.security_level == SecurityLevel.MEDIUM:
                score += 0.5
            elif vulnerability.security_level == SecurityLevel.LOW:
                score += 0.25
        
        # Add points for high-risk relationships
        for relationship in self.relationships.values():
            if relationship.risk_level == CapabilityRiskLevel.CRITICAL:
                score += 1.5
            elif relationship.risk_level == CapabilityRiskLevel.HIGH:
                score += 1.0
        
        # Cap the score at 10.0
        return min(10.0, score)


# Create a singleton instance
capability_auditor = ServerCapabilityAuditor() 